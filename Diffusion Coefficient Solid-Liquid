import numpy as np
import pylab as plt
from time import clock

tStart = clock()
lines = open('HISTORY','r').readlines()

comp = str.split(lines[2])[0]  

Npart = int(str.split(lines[1])[2])
numtStep = int(str.split(lines[1])[3])
bs = float(str.split(lines[3])[0])

Nlines = (Npart*2)-1

x = [[0 for a in range(Npart)] for b in range(numtStep)] 
y = [[0 for a in range(Npart)] for b in range(numtStep)]
z = [[0 for a in range(Npart)] for b in range(numtStep)]

dx = [[0 for a in range(Npart)] for b in range(numtStep)]
dy = [[0 for a in range(Npart)] for b in range(numtStep)]
dz = [[0 for a in range(Npart)] for b in range(numtStep)]

x = np.array(x,float)
y = np.array(y,float)
z = np.array(z,float)

dx = np.array(dx,float)
dy = np.array(dy,float)
dz = np.array(dz,float)

time = []
MSD = []
ln = 0
count = -1

for i in range(len(lines)):
    LSA = str.split(lines[i])    
    if LSA[0] == comp:
        time.append(float(str.split(lines[i])[6]))        
        ln = i+5
        count +=1
        p = -1
        for j in range(ln,ln+Nlines):
            LSA = str.split(lines[j])
            if len(LSA) == 3:
                p +=1
                x[count][p] = float(str.split(lines[j])[0])     
                y[count][p] = float(str.split(lines[j])[1])
                z[count][p] = float(str.split(lines[j])[2])

for i in range(numtStep):
    for j in range(Npart):
      if i == 0:
        pass
      else:
        dx[i][j] = x[i][j]-x[i-1][j]
        dy[i][j] = y[i][j]-y[i-1][j]
        dz[i][j] = z[i][j]-z[i-1][j]
       
        if dx[i][j] > bs/2.0:
          dx[i][j]=bs-dx[i][j]

        elif dx[i][j] < -bs/2.0:
          dx[i][j] = bs+dx[i][j] 

        if dy[i][j] > bs/2.0:
          dy[i][j]=bs-dy[i][j]

        elif dy[i][j] < -bs/2.0:
          dy[i][j] = bs+dy[i][j]
    
        if dz[i][j] > bs/2.0:
          dz[i][j]=bs-dz[i][j]

        elif dz[i][j] < -bs/2.0:
          dz[i][j] = bs+dz[i][j]

xCor = [[0 for a in range(Npart)] for b in range(numtStep)] 
yCor = [[0 for a in range(Npart)] for b in range(numtStep)] 
zCor = [[0 for a in range(Npart)] foantsr b in range(numtStep)]

xCor = np.array(xCor,float)
yCor = np.array(yCor,float)
zCor = np.array(zCor,float)

for i in range(numtStep):
   for j in range(Npart):
     if i ==0:
       xCor[i] = x[0]
       yCor[i] = y[0]
       zCor[i] = z[0]
     else:
       xCor[i][j] = dx[i][j]+xCor[i-1][j]
       yCor[i][j] = dy[i][j]+yCor[i-1][j]
       zCor[i][j] = dz[i][j]+zCor[i-1][j]

xCorF = [[0 for a in range(6760)] for b in range(numtStep)] 
yCorF = [[0 for a in range(6760)] for b in range(numtStep)] 
zCorF = [[0 for a in range(6760)] for b in range(numtStep)]

xCorF = np.array(xCorF,float)
yCorF = np.array(yCorF,float)
zCorF = np.array(zCorF,float)

for i in range(numtStep):
    p = -1
    for j in range(2048,7808):
      p += 1
      xCorF[i][p] = xCor[i][j]
      yCorF[i][p] = yCor[i][j]
      zCorF[i][p] = zCor[i][j]

for j in range(numtStep):
  xSum = sum((xCorF[j]-xCorF[0])**2+(zCorF[j]-zCorF[0])**2)
  xSum = xSum/5760
  MSD.append(xSum)

chy = []
chx = []
grad = []

for i in range(1,numtStep): 
  chy.append(MSD[i]-MSD[i-1])
  chx.append(time[i]-time[i-1])

chy = np.array(chy,float)
chx = np.array(chx,float)

grad.append(chy/chx)
grad = np.array(grad,float)

grad2 = sum(grad[0])/len(grad[0])
print(grad2)
plt.plot(time,MSD)
plt.grid(True)
slope=np.polyfit(time,MSD,1)
DC=slope[0]/4
print(slope)
print('Diffusion Coeffiecient:', DC)
tEnd = clock()
print("Time for code:",tEnd - tStart)
plt.show()

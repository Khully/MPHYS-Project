#importing the module used in the code
import numpy as np
import pylab as plt

#reading in the lines from the simulation data file 
lines = open('HISTORYWater','r').readlines()

#this is a comparison variable for the first **for** loop
comp = str.split(lines[2])[0]  

#defining variables taken from the data file
Npart = int(str.split(lines[1])[2])
numtStep = int(str.split(lines[1])[3])
bs = float(str.split(lines[3])[0])

Nlines = (Npart*2)-1

x = [[0 for a in range(Npart)] for b in range(numtStep)] 
y = [[0 for a in range(Npart)] for b in range(numtStep)]
z = [[0 for a in range(Npart)] for b in range(numtStep)]

dx = [[0 for a in range(Npart)] for b in range(numtStep)]
dy = [[0 for a in range(Npart)] for b in range(numtStep)]
dz = [[0 for a in range(Npart)] for b in range(numtStep)]

x = np.array(x,float)
y = np.array(y,float)
z = np.array(z,float)

dx = np.array(dx,float)
dy = np.array(dy,float)
dz = np.array(dz,float)

time = []
MSD = []
ln = 0
count = -1

#the following loop is to only store the relevant information from the data file
#This is the xyz coordinates of all the lqiuid particles at every timestep
#the columns is the timestep counter
#the rows are the coordinates
#the coordinates are saved into three separate arrays
for i in range(len(lines)):
    LSA = str.split(lines[i])    
    if LSA[0] == comp:
        time.append(float(str.split(lines[i])[6]))        
        ln = i+5
        count +=1
        p = -1
        for j in range(ln,ln+Nlines):
            LSA = str.split(lines[j])
            if len(LSA) == 3:
                p +=1
                x[count][p] = float(str.split(lines[j])[0])     
                y[count][p] = float(str.split(lines[j])[1])
                z[count][p] = float(str.split(lines[j])[2])

for i in range(numtStep):
    for j in range(Npart):
      if i == 0:
        pass
      else:
        dx[i][j] = x[i][j]-x[i-1][j]
        dy[i][j] = y[i][j]-y[i-1][j]
        dz[i][j] = z[i][j]-z[i-1][j]
       
        if dx[i][j] > bs/2.0:
          dx[i][j]=bs-dx[i][j]

        elif dx[i][j] < -bs/2.0:
          dx[i][j] = bs+dx[i][j] 

        if dy[i][j] > bs/2.0:
          dy[i][j]=bs-dy[i][j]

        elif dy[i][j] < -bs/2.0:
          dy[i][j] = bs+dy[i][j]
    
        if dz[i][j] > bs/2.0:
          dz[i][j]=bs-dz[i][j]

        elif dz[i][j] < -bs/2.0:
          dz[i][j] = bs+dz[i][j]

xCor = [[0 for a in range(Npart)] for b in range(numtStep)] 
yCor = [[0 for a in range(Npart)] for b in range(numtStep)] 
zCor = [[0 for a in range(Npart)] for b in range(numtStep)]

xCor = np.array(xCor,float)
yCor = np.array(yCor,float)
zCor = np.array(zCor,float)

  
for i in range(numtStep):
   for j in range(Npart):
     if i ==0:
       xCor[i] = x[0]
       yCor[i] = y[0]
       zCor[i] = z[0]
     else:
       xCor[i][j] = dx[i][j]+xCor[i-1][j]
       yCor[i][j] = dy[i][j]+yCor[i-1][j]
       zCor[i][j] = dz[i][j]+zCor[i-1][j]


for j in range(numtStep):
  xSum = sum((xCor[j]-xCor[0])**2+(yCor[j]-yCor[0])**2+(zCor[j]-zCor[0])**2) 
  xSum = xSum/Npart
  MSD.append(xSum)

chy = []
chx = []
grad = []

for i in range(1,numtStep): 
  chy.append(MSD[i]-MSD[i-1])
  chx.append(time[i]-time[i-1])

chy = np.array(chy,float)
chx = np.array(chx,float)

grad.append(chy/chx)
grad = np.array(grad,float)

grad2 = sum(grad[0])/len(grad[0])
print(grad2)

plt.plot(time,MSD)
plt.grid(True)
slope=np.polyfit(time,MSD,1)
DC=slope[0]/6
print(slope)
print('Diffusion Coeffiecient:', DC)
plt.show()
